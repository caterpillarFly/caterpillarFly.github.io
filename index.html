<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="浮生若梦">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="浮生若梦">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="浮生若梦">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>浮生若梦</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">浮生若梦</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/18/OC对象和非OC对象间的转换/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="浮生若梦">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浮生若梦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/18/OC对象和非OC对象间的转换/" itemprop="url">OC对象和Core Foundation对象间的转换</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-18T19:47:05+08:00">
                2017-07-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/07/18/OC对象和非OC对象间的转换/" class="leancloud_visitors" data-flag-title="OC对象和Core Foundation对象间的转换">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Core Foundation框架，是一组由C语言编写的接口，它所使用的对象，称之为Core Foundation对象，也是使用引用计数。CF对象与OC对象的区别很小，且可以混合使用。Foundation框架的API生成的对象，可以用Core Foundataion框架的API释放，反之亦然。</p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>Core Foundation框架提供了一下几个函数来进行内存管理，<strong>CFBridgingRetain</strong>，<strong>CFBridgingRelease</strong>。这两个函数分别和<strong>__bridge_retain</strong>，<strong>__bridge_release</strong>等价。另外，CF框架还提供了一个函数，来查看对象的引用计数，即：<strong>CFGetRetainCount</strong>。下面分别举例说明这几个函数的用法及内存管理情况：</p>
<h2 id="bridge"><a href="#bridge" class="headerlink" title="__bridge"></a>__bridge</h2><p>以下代码，将OC对象与void*指针进行相互转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void *p;</div><div class="line">&#123;</div><div class="line">  id obj = [[NSObject alloc] init];</div><div class="line">  p = (__bridge void *)obj;			//id对象转换成void*指针</div><div class="line">  id op = (__bridge id)p;			//void*指针转换成id对象</div><div class="line">&#125;</div><div class="line">//这行代码会崩溃，因为指针指向的对象已经释放，即指针是野指针了</div><div class="line">id obj = (__bridge id)p;</div></pre></td></tr></table></figure>
<p>转换为void *的__bridge转换，其安全性与赋值给__unsafe_unretained修饰符相近，如果不注意赋值对象的所有者，就会因悬挂指针而导致程序崩溃。</p>
<h2 id="bridge-retained"><a href="#bridge-retained" class="headerlink" title="__bridge_retained"></a>__bridge_retained</h2><p>__bridge<em>retained主要是将OC对象转换为CF对象。它和CFBridgingRetain等价，\</em>_bridge_retained转换，可使要转换赋值的变量也持有所赋值的对象。下面通过代码说明对象内存的管理情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">CFMutableArrayRef cfObject = NULL;</div><div class="line">&#123;</div><div class="line">  	id obj = [[NSMutableArray alloc] init];</div><div class="line">    //cfobject也持有对象，引用+1</div><div class="line">  	cfobject = CFBridgingRetain(obj);		</div><div class="line">  	//该代码和下行转换代码等价</div><div class="line">  	//cfobject = (__bridge_retained CFTypeRef)obj;</div><div class="line">  	printf(&quot;retain count = %ld\n&quot;, CFGetRetainCount(cfobj));</div><div class="line">&#125;</div><div class="line">printf(&quot;retain count after the scope = %ld\n&quot;, CFGetRetainCount(cfobj));</div><div class="line">CFRelease(cfobject);</div></pre></td></tr></table></figure>
<p>代码运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">retain count = 2</div><div class="line">retain count after the scope = 1</div></pre></td></tr></table></figure>
<p>可以看出，通过__bridge_retained转换，对象的引用计数加1了，而且，如果不调用CFRelease进行释放的话，会造成内存泄露。可以看出，Foundation框架的API生成的OC对象，可以作为Core Foundation对象来使用，也可以通过CFRelease来释放。</p>
<p>那如果使用__bridge代替__bridge_retained，会是什么情况呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CFMutableArrayRef cfObject = NULL;</div><div class="line">&#123;</div><div class="line">  	id obj = [[NSMutableArray alloc] init];</div><div class="line">  	//cfobject并不持有对象</div><div class="line">  	cfobject = (__bridge CFTypeRef)obj;</div><div class="line">  	printf(&quot;retain count = %ld\n&quot;, CFGetRetainCount(cfobj));</div><div class="line">&#125;</div><div class="line">printf(&quot;retain count after the scope = %ld\n&quot;, CFGetRetainCount(cfobj));</div><div class="line">CFRelease(cfobject);</div></pre></td></tr></table></figure>
<p>结果输出：retain count = 1，并在第二个打印语句那崩溃。为什么呢？因为前面说过，__bridge转换并不会改变对象的持有状况，所以引用计数还是1。且超出作用域之后，cfobject就变为野指针。访问野指针造成程序崩溃。</p>
<h2 id="bridge-transfer"><a href="#bridge-transfer" class="headerlink" title="__bridge_transfer"></a>__bridge_transfer</h2><p>与__bridge<em>retained相反，\</em>_bridge_transfer将CF对象转换成OC对象。并且，被转换的变量，它所持有的对象，在它被赋值给转换目标后随之释放。看以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  	CFMutableArrayRef cfobj = CFArrayCreateMutable(kCFAllocatorDefault, 0, NULL);</div><div class="line">  	printf(&quot;retain count = %ld\n&quot;, CFGetRetainCount(cfobj));</div><div class="line">  	id obj = CFBridgingRelease(cfobj);</div><div class="line">  	//这个转换和以下转换等价：</div><div class="line">	//id obj = (__bridge_transfer id)cfobj;</div><div class="line">  	//注意，虽然cfobj不再持有对象的引用，但是指针还是有效的，还是其正常作用域范围</div><div class="line">  	printf(&quot;retain count after the cast = %ld\n&quot;, CFGetRetainCount(cfobj));    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">retain count = 1</div><div class="line">retain count after the cast = 1</div></pre></td></tr></table></figure>
<p>经过__bridge<em>transfer转换，对象的引用计数没有改变，且CF框架创建的对象cfobj，并没有调用CFRelease进行释放，这是因为经过\</em>_bridge_transfer转换后，cfobj不再持有对象的引用，故而不需要进行释放。但obj持有对象引用，它的释放是有ARC自动进行的。</p>
<p>同样，如果用__bridge来代替__bridge_transfer，将会是什么情况呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  	CFMutableArrayRef cfobj = CFArrayCreateMutable(kCFAllocatorDefault, 0, NULL);</div><div class="line">  	printf(&quot;retain count = %ld\n&quot;, CFGetRetainCount(cfobj));</div><div class="line">	id obj = (__bridge id)cfobj;</div><div class="line">  	printf(&quot;retain count after the cast = %ld\n&quot;, CFGetRetainCount(cfobj));    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">retain count = 1</div><div class="line">retain count after the cast = 2</div></pre></td></tr></table></figure>
<p>为什么引用计数加1了？因为id obj = (_<em>bridge id)cfobj;其实和 id \</em>_strong obj = (__bridge id)cfobj等价。所以obj会持有对象的强引用，从而引用计数加1。到{}结束时，OC对象obj超出作用域，其强引用失效，对象引用计数减一。但是，cfobj对象还持有引用，它也没有调用CFRelease进行释放，对象的引用计数还为1，从而造成内存泄露。</p>
<p>所以，在将CF对象通过__bridge转换成OC对象时，一定要注意对象的释放问题。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/08/iOS内存管理（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="浮生若梦">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浮生若梦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/08/iOS内存管理（二）/" itemprop="url">iOS内存管理（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-08T11:52:38+08:00">
                2017-07-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/07/08/iOS内存管理（二）/" class="leancloud_visitors" data-flag-title="iOS内存管理（二）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>ARC，即Automatic Reference Counting，字面意思“自动引用计数”， ARC只是自动的帮助我们处理“引用计数”相关的部分。关于引用计数的思考方式并没有发生变化，只是在源码的表述上稍有不同，发生了什么变化呢？首先要理解ARC中追加的所有权声明。</p>
<h1 id="所有权修饰符"><a href="#所有权修饰符" class="headerlink" title="所有权修饰符"></a>所有权修饰符</h1><p>OC中，为了处理对象，将变量定义为id类型或各种对象类型，比如id，NSObject *等。在ARC有效时，OC对象类型同C语言其它类型不同，其类型上必须附加所有权修饰符。所有权修饰符一共有四种，是：__strong，__weak，__unsafe_unretained，__autoreleasing。附有这些修饰符的变量，会自动初始化为nil。以下对每种修饰符进行简单讲解。</p>
<h2 id="strong修饰符"><a href="#strong修饰符" class="headerlink" title="__strong修饰符"></a>__strong修饰符</h2><p>__strong修饰符表示对对象的“强引用”，持有强引用的变量在超出其作用域范围时被废弃，随着强引用的失效，其引用的对象会随之释放。（自动释放）<br>__strong修饰符是OC所有对象默认的所有权修饰符。也就是说，以下代码是等效的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  //自己生成并持有对象</div><div class="line">  id obj = [[NSObject alloc] init];</div><div class="line">  //和以下代码等价的</div><div class="line">  id __strong obj = [[NSObject alloc] init];</div><div class="line">&#125;</div><div class="line">//obj超出其作用域，强引用失效，所以自动释放obj所持有的对象。该对象的所有者不存在，因此废弃该对象</div></pre></td></tr></table></figure></p>
<p>在ARC无效的情况下，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/* ARC无效 */</div><div class="line">&#123;</div><div class="line">    //自己生成并持有对象</div><div class="line">    id obj = [[NSObject alloc] init];</div><div class="line">    //不再需要对象时，释放</div><div class="line">    [obj release];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码取得的是自己生成并持有的对象，那取得非自己生成并持有的对象该怎么办呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  //自己非生成并持有对象</div><div class="line">  id __strong obj = [NSMutableArray array];</div><div class="line">  //因为变量obj为强引用，所以它自己持有对象</div><div class="line">&#125;</div><div class="line">//obj超出其作用域，强引用失效，所以自动释放obj所持有的对象。该对象的所有者不存在，因此废弃该对象</div></pre></td></tr></table></figure></p>
<p>其实上述代码，最终会被编译器转换成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">id obj = objc_msgSend(NSMutableArray, @selector(array));</div><div class="line">objc_retainAutoreleasedReturnValue(obj);</div><div class="line">objc_release(obj);</div></pre></td></tr></table></figure>
<p>可以看出，__strong修饰符可以自动持有对象，尽管对象非自己生成并持有的。<br>通过上述几段代码，可以发现，“自己生成的对象，自己持有”和“非自己生成的对象，自己也能持有”这两条只需通过对带__strong修饰符的变量赋值即可完成。而“不再需要持有的对象时自己释放”，当变量超出作用域范围（或者对变量进行重新赋值）时，会自动触发。最后一条“非自己持有的对象，自己不能释放“，由于不能调用release方法，所以这条自然也满足。</p>
<h2 id="weak修饰符"><a href="#weak修饰符" class="headerlink" title="__weak修饰符"></a>__weak修饰符</h2><p>看起来好像通过__strong修饰符就能很好的管理内存了，但是仅有__strong是不够的，它无法解决引用计数式内存管理中无法避免的”<strong>循环引用</strong>“问题，所以才有__weak修饰符。<br>__weak与__strong相反，提供弱引用。弱引用不能持有对象实例。__weak修饰符还有一个优点，即在持有某对象的弱引用时，若该对象被废弃，则次弱引用将自动置为nil，反过来，也可以通过检查有__weak修饰符的变量是否为nil，来判断被赋值的对象是否被废弃。<br>使用__weak修饰符时需要注意，不能直接生成对象并对其赋值，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id __weak obj = [[NSObject alloc] init];</div></pre></td></tr></table></figure></p>
<p>[[NSObject alloc] init]属于自己生成并持有的对象，但__weak修饰符不能持有对象实例，所以生成的对象会被立即释放，编译器对此会发出警告。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  //obj0为强引用，自己生成并持有对象</div><div class="line">  id __strong obj0 = [[NSObject alloc] init];</div><div class="line">  //obj1持有生成对象的弱引用</div><div class="line">  id __weak obj1 = obj0;</div><div class="line">&#125;</div><div class="line">//obj0超出作用域，强引用失效，所以自动释放它持有的对象。因为对象没有持有者了，所以废弃该对象</div></pre></td></tr></table></figure></p>
<p>那又是如何做到__weak变量，在它弱引用的对象释放后，自动置为nil的呢？</p>
<p>答案是系统会维持一张weak表，也是散列表，该对象作为建，弱引用它的weak变量为值，如果有多个弱引用的话，则会形成类似链表的结构，所以当该对象自动释放时，会遍历这个weak表，找出它对应的弱引用，然后将它们置为nil，并删除相应的键值记录。由此可知，如果大量使用附有__weak修饰符的变量，会消耗相应的CPU资源。</p>
<h2 id="unsafe-unretained修饰符"><a href="#unsafe-unretained修饰符" class="headerlink" title="__unsafe_unretained修饰符"></a>__unsafe_unretained修饰符</h2><p>正如其名unsafe所言，是不安全的所有权修饰符。尽管ARC式的内存管理是编译器的工作，但附有__unsafe_unretained修饰符的变量不属于编译器的内存管理对象。它的作用和__weak修饰符变量类似，但它并不持有对象的强引用或弱引用，而且它表示的对象一旦被废弃，它并不会被置为nil，而是变成野指针，所以尽量不要使用__unsafe_unretained。</p>
<h2 id="autoreleasing修饰符"><a href="#autoreleasing修饰符" class="headerlink" title="__autoreleasing修饰符"></a>__autoreleasing修饰符</h2><p>无论ARC是否有效，都可使用非公开函数<strong>_objc_autoreleasingPoolPrint()</strong>来打印Pool信息。</p>
<p>先看一下，在非ARC的情况下，怎么使用autorelease的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];</div><div class="line">id obj = [[NSObject alloc] init];</div><div class="line">[obj autorelease];</div><div class="line">[pool drain];</div></pre></td></tr></table></figure>
<p>NSAutoreleasePool对象的生命周期，相当于变量作用域。对该周期内，所有调用过autorelease方法的对象，在pool被废弃时，会自动向它发送release消息。<br>在ARC情况下，代码可改写如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@autoreleasepool &#123;</div><div class="line">    id __autoreleasing obj = [[NSObject alloc] init];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>@autoreleasepool{}来代替NSAutoreleasePool类对象的生成、持有以及废弃这一范围。通过给变量附加__autoreleasing修饰符，来代替向变量发送autorelease消息，即对象被注册到autoreleasepool中。<br>上一篇博文说道，如何获取非自己生成并持有的对象，主要就是通过在非alloc、new、copy、mutableCopy等方法返回的对象上调用autorelease方法。那在ARC的情况下又是怎么样的呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ (id)array</div><div class="line">&#123;</div><div class="line">    return [[NSMutableArray alloc] init];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是这段代码，经过编译器的转换之后，将变成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+ (id)array</div><div class="line">&#123;</div><div class="line">    id obj = objc_msgSend(NSMutableArray, @selector(alloc));</div><div class="line">    objc_msgSend(obj, @selector(init));</div><div class="line">    return objc_autoreleaseReturnValue(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>转换的最后，调用了一个函数：<strong>objc_autoreleaseReturnValue</strong>，它与一般的<strong>objc_autorelease</strong>函数不同，它不仅限于注册对象到autoreleasePool中。它还有一个与之配对的函数：<strong>objc_retainAutoreleasedReturnValue</strong>。这对函数主要用于极致优化程序运行，怎么个优化法呢？</p>
<p><strong>objc_autoreleaseReturnValue</strong>函数会检查使用该函数的方法或函数调用方的执行命令列表，如果调用方在调用了该函数后紧接着调用<strong>objc_retainAutoreleasedReturnValue</strong>函数，那么久不讲返回的对象注册到autoreleasePool中，而是直接传递到函数的调用方。通过这两个函数，就可以不将对象注册到autoreleasePool中而直接传递，这一过程达到了最优化。</p>
<p>所以，array方法返回的对象，不一定注册到了autoreleasePool中，那么看以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@autoreleasePool&#123;</div><div class="line">    id __strong obj = [NSMutableArray array];</div><div class="line">    _objc_autoreleasingPoolPrint();     //打印当前释放池的信息</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>猜想一下，Pool中是否有obj这一对象呢？经过试验，答案是没有，以上的优化过程可以解释为什么。</p>
<p>前面说到，id obj其实就是id __strong obj，那么id *obj呢，也是id __strong *obj吗？答案是NO，它对应的是：id __autoreleasing *obj；像这样，id的指针或对象的指针，在没有指定修饰符的情况下，默认会加上__autoreleasing修饰符。</p>
<p>我们经常看到一些方法，在参数里面返回error信息，方法声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (BOOL)performOperationWithError:(NSError **)error;</div><div class="line">//等价于</div><div class="line">- (BOOL)performOperationWithError:(NSError * __autoreleasing *)error;</div></pre></td></tr></table></figure>
<p>调用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSError *error = nil;   //等价于NSError __strong *error</div><div class="line">BOOL result = [obj performOperationWithError:&amp;error];</div></pre></td></tr></table></figure>
<p>苹果自身很多API也是通过这样的方式返回错误信息的。</p>
<p>但是，如果直接赋值，那么会产生编译器错误，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSError *error = nil;</div><div class="line">NSError **pError = &amp;error;      //编译器会报错</div></pre></td></tr></table></figure>
<p>这是因为，赋值给<strong>指针对象</strong>时，对象的所有权修饰符必须保持一致。因为error变量附加有__strong修饰符，而pError则附加有__autoreleasing修饰符，所以报错。可更改为：NSError  * __strong  *pError = &amp;error即可。</p>
<p>但是，之前的函数调用，使用__strong修饰符的error变量，并没有进行转换，也没有报错呀，这是为什么呢？这是因为编译器自动进行了如下转化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSError __strong *error = nil;</div><div class="line">NSError __autoreleasing *tmpError = error;</div><div class="line">BOOL result = [obj performOperationWithError:&amp;error];</div></pre></td></tr></table></figure>
<h1 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h1><p>在ARC的情况下，怎么知道对象的引用计数值呢？</p>
<p><strong>uintptr_t  _objc_rootRetainCount(id obj);</strong></p>
<p>该函数可以取得对象的计数值。但是，该函数是非线程安全的，且对于已释放的对象和不正确的对象类型，返回的值也是不准确的。所以该函数只提供一个参考值。</p>
<h1 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h1><ol>
<li><p>书籍上说，在访问附有__weak修饰符的变量时，实际上必定要访问注册到autoreleasePool中的对象，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">id obj0 = [[NSObject alloc] init];</div><div class="line">id __weak obj1 = obj0;</div><div class="line">NSLog(@&quot;class=%@&quot;,[obj1 class]);</div></pre></td></tr></table></figure>
<p>上述代码和一下代码相同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">id __weak obj1 = obj0;</div><div class="line">id __autoreleasing tmp = obj1;</div><div class="line">NSLog(@&quot;class=%@&quot;,[tmp class]);</div></pre></td></tr></table></figure>
<p>但实际试验结果和书上所说有所出入，如果把两段代码放入@autoreleasePool{}里面，然后打印Pool的信      息，就会发现下面的代码，池子里面包含了对象obj0，但是上面的代码则没有包含。所以访问__weak变量，实际上必定访问注册到autoreleasePool中的对象，对此持保留态度。</p>
</li>
<li><p>我们一般都是这样使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@autoreleasepool &#123;</div><div class="line">    id obj = [[NSObject alloc] init];</div><div class="line">     id mArray = [NSMutableArray array];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>经过上面讲述的优化过程，知道obj和mArray并不会注册到autoreleasePool中，打印Pool信息，也确实没发现这两个对象。既然没注册到Pool里面，那么外面的@autoreleasepool{}块还有用吗？</p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/15/iOS内存管理（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="浮生若梦">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浮生若梦">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/15/iOS内存管理（一）/" itemprop="url">iOS内存管理（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-15T16:43:18+08:00">
                2017-06-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/06/15/iOS内存管理（一）/" class="leancloud_visitors" data-flag-title="iOS内存管理（一）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这两篇博文是阅读《iOS与OS X多线程和内存管理》之后整理得来的，有错误之处，请指正！</p>
<h1 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h1><p>顾名思义，引用计数是指内存管理中对引用采用计数的技术。 对于引用计数，我们很自然的联想到“某处有某物多少多少”而将注意力放在计数上。但更客观、正确的思考方式是：</p>
<ol>
<li><p>自己生成的对象，自己持有</p>
</li>
<li><p>非自己生成的对象，自己也能持有</p>
</li>
<li><p>不再需要自己持有的对象时自己释放</p>
</li>
<li><p>非自己持有的对象无法释放</p>
</li>
</ol>
<p>上面出现了”生成“、”持有“、”释放“三个词，而在Object-C内存管理中，还应该加上”废弃“一词。各个词表示的Object-C方法表如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">right aligned</th>
<th>Objective-C方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">生成并持有对象</td>
<td>alloc/new/copy/mutableCopy 等方法</td>
</tr>
<tr>
<td style="text-align:left">持有对象</td>
<td>retain 方法</td>
</tr>
<tr>
<td style="text-align:left">释放对象</td>
<td>release 方法</td>
</tr>
<tr>
<td style="text-align:left">废弃对象</td>
<td>dealloc 方法</td>
</tr>
</tbody>
</table>
<p>这些有关Objective-C内存管理的方法，并没包含在语言中，而是在Cocoa框架中。准确的说由Foundation框架类库的NSObject类负责内存管理职责。以下将对表格进行简单说明</p>
<h1 id="自己生成的对象，自己持有"><a href="#自己生成的对象，自己持有" class="headerlink" title="自己生成的对象，自己持有"></a>自己生成的对象，自己持有</h1><p>使用以下名称开头的方法名意味着自己生成的对象只有自己持有：</p>
<ul>
<li><p>alloc</p>
</li>
<li><p>new</p>
</li>
<li><p>copy</p>
</li>
<li><p>mutableCopy</p>
</li>
</ul>
<p>只要符合上述<strong>以什么开头</strong>的规则，且方法名满足<strong>驼峰命名</strong>要求，那么它们生成的对象也会被自己持有，比如：allocMyObject，newThatObject， copyThis，mutableCopyThat。相反，如果不符合驼峰命名，比如：allocate，newer，copying等方法所产生的对象则不会自己持有。</p>
<h1 id="非自己生成的对象，自己也能持有"><a href="#非自己生成的对象，自己也能持有" class="headerlink" title="非自己生成的对象，自己也能持有"></a>非自己生成的对象，自己也能持有</h1><p>默认情况下，使用alloc/new/copy/mutableCopy以外的方法取得的对象，因为非自己生成，所以自己不是该对象的持有者。使用retain方法可以持有该对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//取得非（自己生成并持有）的对象，取得了对象的存在，但并不持有该对象</div><div class="line">id obj = [NSMutableArray array];</div><div class="line">//自己持有该对象</div><div class="line">[obj retain];</div></pre></td></tr></table></figure>
<p>通过retain方法，非自己生成的对象跟用alloc/new/copy/mutableCopy方法生成的对象一样，成为自己持有的了。</p>
<h1 id="不在需要自己持有的对象时释放"><a href="#不在需要自己持有的对象时释放" class="headerlink" title="不在需要自己持有的对象时释放"></a>不在需要自己持有的对象时释放</h1><p>自己持有的对象，当不再需要时，必须自己进行释放。释放使用release方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//自己生成并持有对象</div><div class="line">id obj = [[NSObject alloc] init];</div><div class="line">//释放对象</div><div class="line">[obj release];</div><div class="line">//此时，指向对象的指针仍然保留在变量中，但对象一经释放，就绝对不能再访问</div></pre></td></tr></table></figure>
<p>如此，由自己生成并持有的对象就释放了。对于非自己生成并持有的对象，如果使用retain方法变为自己持有，那么自己也得负责释放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//取得非（自己生成并持有）的对象，取得了对象的存在，但并不持有该对象</div><div class="line">id obj = [NSMutableArray array];</div><div class="line">//自己持有该对象</div><div class="line">[obj retain];</div><div class="line">//释放对象</div><div class="line">[obj release];</div></pre></td></tr></table></figure>
<p>思考一下，NSMutableArray类的array方法，因为它不是以alloc/new/copy/mutableCopy等名称开头，所以它不会持有生成的对象，但是它内部肯定调用了alloc来生成对象，从而取得了对象的存在。这是怎么实现的呢？？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">+ (id)array</div><div class="line">&#123;</div><div class="line">    //生成并自己持有对象</div><div class="line">    id obj = [[NSMutableArray alloc] init];</div><div class="line">    //取得对象的存在，但不再持有对象</div><div class="line">    [obj autorelease];</div><div class="line">    //如果没有调用autorelease方法，而是直接返回，那么obj没有调用release方法，所以没有被释放，外部调用方</div><div class="line">    //因为方法名为object，所以调用方并不会持有返回对象，从而也不会释放它，因此就会造成内存泄露</div><div class="line">    return obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//取得对象存在，但不持有该对象</div><div class="line">id obj = [obj0 object];</div></pre></td></tr></table></figure>
<p>通过<strong>autorelease</strong>方法，我们可以取得对象的存在，但却不持有该对象。同时，autorelease方法使得对象在超出指定的生存范围时能够自动并正确的释放。<br>当然，也能够通过retain方法将调用autorelease方法取得的对象变为自己持有。</p>
<h1 id="无法释放非自己持有的对象"><a href="#无法释放非自己持有的对象" class="headerlink" title="无法释放非自己持有的对象"></a>无法释放非自己持有的对象</h1><p>对于alloc/new/copy/mutableCopy方法生成并持有的对象，或是用retain方法持有的对象，持有者在不需要该对象的时候，有义务对其进行释放。而由此以外得到的对象，绝对不能释放。如果释放了非自己持有的对象，会Crash，Crash，Crash！！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">id obj1 = [[NSObject alloc] init];</div><div class="line">//自己持有的对象，自己进行释放</div><div class="line">[obj1 release];</div><div class="line"></div><div class="line">id obj2 = [obj0 object];</div><div class="line">//非自己持有的对象，进行释放，后果Crash...</div><div class="line">[obj2 release];</div></pre></td></tr></table></figure>
<p>以上四项内容就是引用计数的思考方式，接下来会介绍在ARC下，这些规则会有哪些变化。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>《Objective-C高级编程——iOS与OS X多线程和内存管理》</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="浮生若梦" />
          <p class="site-author-name" itemprop="name">浮生若梦</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">浮生若梦</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("ER1WqqqiRkb5OESscBlpnDQn-gzGzoHsz", "mcK1Mwxg2tWp1IpifikaLgde");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
